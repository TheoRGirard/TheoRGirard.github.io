<!DOCTYPE HTML>
<!--
	Prologue by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Theo Girard</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<link href="../assets/css/custom.css" rel="stylesheet">
		<link rel="icon" type="image/x-icon" href="../images/favMath.png">
	</head>
	<body class="is-preload">

		<!-- Header -->
			<div id="header">

				<div class="top">

					<!-- Logo -->
						<div id="logo">
							<a href="/#CoursesList" id="about-link"><span class="icon solid fa-arrow-left backButton">Retour</span></a>
						</div>

					<!-- Nav -->
						<nav id="nav">
							<ul>
								<li><a href="#chap1" id="chap1-link">Introduction</a></li>
								<li><a href="#chap2" id="chap2-link">Théorèmes</a></li>
                <li><a href="#chap3" id="chap3-link">Parcours DFS/BFS</a></li>
                <li><a href="#chap4" id="chap4-link">Programmation dynamique</a></li>
								<li><a href="#chap8" id="chap8-link">Problèmes</a></li>
							</ul>
						</nav>

				</div>

				<div class="bottom">

					<!-- Social Icons -->
						<ul class="icons">
							<li><a href="https://github.com/TheoRGirard" class="icon brands fa-github"><span class="label">Github</span></a></li>
							<li><a href="/#contact" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
						</ul>

				</div>

			</div>

		<!-- Main -->
			<div id="main">

        <section id="top" class="one dark cover">
          <div class="container">

            <header>
              <h2 class="alt">Théorie des graphes</h2>
<h3>(En construction)</h3>
            </header>

            <footer>
              <a href="#chap1" class="button scrolly">Introduction</a>
              <a href="#chap2" class="button scrolly">Théorèmes</a>
              <a href="#chap3" class="button scrolly">Parcours DFS/BFS</a>
              <a href="#chap4" class="button scrolly">Programmation dynamique</a>
							<a href="#chap8" class="button scrolly">Problèmes</a>
            </footer>

          </div>
        </section>

				<!-- Portfolio -->
					<section id="chap1" class="two">
						<div class="container course">
              <header>
                <h2>Introduction</h2>
              </header>

              <p>La théorie des graphes est une branche des mathématiques qui étudie les relations entre les objets (appelés sommets ou nœuds) et les connexions entre eux (appelées arêtes ou arcs). Elle est utilisée dans de nombreux domaines comme les réseaux sociaux, les systèmes de transport, les circuits électriques et l'analyse de données.</p>

              <p><strong>Pour manipuler les graphes visuellement :</strong> <a href="https://d3gt.com/index.html">https://d3gt.com/index.html</a></p>

              <h3>Définitions de base</h3>

              <div class="definition">
              <h4>Graphe</h4>
              <p>Un <strong>graphe</strong> G est un ensemble de <strong>sommets</strong> V et un ensemble d'<strong>arêtes</strong> E. Formuellement, un graphe est défini comme une paire G = (V, E), où :</p>
              <ul>
                  <li>V est un ensemble de sommets (ou nœuds),</li>
                  <li>E est un ensemble d'arêtes, chaque arête étant une paire non ordonnée de sommets dans V (pour un graphe non orienté) ou une paire ordonnée de sommets (pour un graphe orienté).</li>
              </ul>
              </div>

              <div class="center">
                  <img src="figures/basicgraph2.png" alt="Exemple de graphe" >
                  <p>V = { 1,2,3,4,5 }<br> E = {(1,2), (1,3), (2,3), (5,2), (2,4)}</p>
              </div>

              <div class="definition">
              <h4>Graphe Orienté et Graphe Non Orienté</h4>
              <ul>
                  <li><strong>Graphe orienté</strong> : Un graphe dans lequel les arêtes sont dirigées, c'est-à-dire que chaque arête est représentée par un couple ordonné de sommets (u, v), où u est le sommet de départ et v le sommet d'arrivée.</li>
                  <li><strong>Graphe non orienté</strong> : Un graphe dans lequel les arêtes ne sont pas dirigées, c'est-à-dire que chaque arête est simplement un ensemble de deux sommets {u, v}, sans ordre particulier.</li>
              </ul>
              </div>

              <div class="center">
                  <p>Exemple de graphe orienté</p>
                  <img src="figures/basicOrientedGraph.png" alt="Exemple de graphe orienté" style="width: 40%;">
                  <p>V = { 1,2,3,4,5 }<br> E = {(1,2), (1,3), (2,3), (3,2), (5,2), (2,4)}</p>
              </div>

              <div class="definition">
              <h4>Degré d'un Sommet</h4>
              <p>Le <strong>degré</strong> d'un sommet v, noté deg(v), est le nombre d'arêtes qui touchent v.</p>
              <p>Dans un graphe orienté, on distingue le <strong>degré entrant</strong> et le <strong>degré sortant</strong>.</p>
              </div>

              <div class="definition">
              <h4>Chemin et Cycle</h4>
              <p>Un <strong>chemin</strong> est une séquence de sommets dans laquelle chaque sommet est adjacent au suivant. Un <strong>cycle</strong> est un chemin dont le premier et le dernier sommet sont identiques.</p>
              </div>

              <h3>Dessiner un graphe en python</h3>
              <p>Dans ce cours, les graphes seront représentés avec les bibliothèques python <code>networkx</code> et <code>matplotlib</code>.</p>

              <div class="code-block">
                  <pre><code>#On importe les deux bibliothèques
import networkx as nx
import matplotlib.pyplot as plt

#On créé le graphe
G = nx.Graph() #Non-orienté
#G = nx.DiGraph() #Orienté

#On créé les noeuds
G.add_node(1)
G.add_nodes_from ([2,3,4,5])

#On ajoute les arrêtes entre les noeuds
G.add_edge(1,2)
e = (2,3)
G.add_edge(*e) # the * unpacks the tuple
G.add_edges_from([(1,2),(1,3),(2,4),(2,5)])

#On dessine le graphe
nx.draw(G, with_labels =True)

#On peut sauvegarder la figure
plt.savefig("basicgraph2.png")

#Ou juste l'afficher
plt.show()</code></pre>
              </div>

              <p>On obtient le résultat suivant :</p>

              <div class="center">
                  <img src="figures/basicgraph2.png" alt="Résultat du graphe" style="width: 40%;">
              </div>

						</div>
					</section>

          <section id="chap2" class="three">
						<div class="container">

							<header>
								<h2>Théorèmes</h2>
							</header>

							<p>Quelques théorèmes de base de la théorie des graphes.</p>

						</div>
					</section>

          <section id="chap3" class="two">
						<div class="container course">

							<header>
								<h2>Parcours de graphe DFS/BFS</h2>
							</header>

							<p>Dans de multiples problèmes nous sommes amenés à parcourir un graphe, c'est-à-dire aller de sommets en sommets en suivant les arrêtes du graphe. Par exemple, pour savoir si deux sommets sont connectés ou pour savoir si le graphe comporte un cycle.
              Pour parcourir un graphe, il existe principalement deux manières de procéder : l'exploration en profondeur DFS (Depth First Search) ou l'exploration en largeur (Breadth First Search).
              Ces deux algorithmes ont des temps de calcul très variables (et complémentaires) en fonction de la forme du graphe.</p>

              <h3> Parcours en profondeur DFS </h3>
              <br/>

              <p>Le parcours en profondeur consiste à parcourir le graphe en utilisant la stratégie suivante : si je suis à une intersection, je choisis une arrête arbitrairement; je continue ce chemin jusqu'à être coincé ou jusqu'à ce que j'aie trouvé ce que je cherche. Si je suis coincé, je reviens sur mes pas jusqu'à la dernière intersection.
                Cette stratégie correspond à la stratégie bien connue pour trouver la sortie d'un labyrinthe : toujours prendre à gauche.
                Voici deux illustrations de la stratégie DFS pour trouver un chemin du sommet A au sommet F à gauche et pour trouver un chemin du sommet A au sommet H à droite.</p>

                <div class="center">
                  En vert, le sommet actuel. En jaune, le sommet qu'on recherche. En rouge les sommets déjà parcourus.
                    <img src="figures/DFS1.gif" alt="Parcours DFS de graphe qui aboutit." style="margin-right:0.5em;"><img src="figures/DFS2.gif" alt="Parcours DFS de graphe qui n'aboutit pas.">
                </div>

              <p>D'un point de vue code, on utilise la plupart du temps un algorithme récursif (bien qu'un algo itératif soit envisageable).
              Voici une implémentation possible en python, en supposant l'existence d'un objet Graphe avec une méthode Voisins qui renvoie la liste des voisins d'un sommet.</p>

              <pre><code class="langage-python">
def explorer(Graphe, sommetActuel, pointArrivee, parcourus):
    parcourus.append(sommetActuel) #On garde en mémoire les sommets par lesquels on est passé.
    if(sommetActuel == pointArrivee): #Condition d'arrêt : on a trouvé le sommet qu'on recherche.
        return True
    for voisin in Graphe.Voisins(sommetActuel): #On parcourt les voisins du sommet.
        if(voisin not in parcourus): #On vérifie qu'on n est pas déjà passé par là.
            if(explorer(Graphe, voisin, pointArrivee, parcourus)): #On continue l'exploration de ce chemin tant qu on n'est pas bloqué.
                return True
    return False #Si on n a trouvé aucun voisin qui n'a jamais été parcouru, on abandonne ce chemin.
                </code></pre>

                <br/>
                <br/>


                <h3> Parcours en largeur BFS </h3>
                <br/>

                <p>Le parcours en largeur consiste à utiliser la stratégie suivante : on explore tous les voisins du point de départ, on liste tous les voisins de ces voisins qui n'ont pas encore été parcourus; on réitère le procédé sur cette nouvelle liste de voisins jusqu'à trouver ce qu'on cherche ou jusqu'à ce qu'on ne trouve plus de voisin non parcourus.
                  Cet algorithme correspond à un parcours par "génération" de voisin. En effet, si on définit la distance de voisinage entre deux sommets A et B comme le nombre d'arrêtes minimal pour passer de A à B, alors le parcours BFS va parcourir tous les sommets à distance 1 du point de départ puis tous les voisins à distance 2 et ainsi de suite.
                  Voici une illustration dans le même contexte que le parcours DFS pour comparer. </p>

                <div class="center">
                  En vert, le sommet actuel. En jaune, le sommet qu'on recherche. En rouge les sommets déjà parcourus.
                    <img src="figures/BFS2.gif" alt="Parcours BFS de graphe qui aboutit.">
                </div>

                <p>Le parcours BFS est généralement implémenté comme un algorithme itératif à la différence du DFS. En voici une implémentation possible en python, en supposant l'existence d'un objet Graphe avec une méthode Voisins qui renvoie la liste des voisins d'un sommet.</p>

                <pre><code class="langage-python">
def explore(Graphe, pointDepart, pointArrivee):
      parcourus = []
      nodesToexplore = [pointDepart] #La liste des noeuds à explorer qui sera tenue à jour à chaque itération.
      while(len(nodesToexplore) > 0):
          newNodes = []
          for node in nodesToexplore:
              if(node == pointArrivee): #Condition d'arrêt : si on a trouvé le point d'arrivée, on arrête.
                  return True
              parcourus.append(node)
              for P in Graphe.Voisins(node):
                  if(P not in parcourus):
                      newNodes.append(P) #On remplit la liste newNodes de tous les voisins non parcourus de la prochaine génération.
          nodesToexplore = newNodes
      return False #Si on a plus aucun noeud à explorer, c'est qu'il n'existe pas de chemin reliant le point de départ au point d'arrivée.
                  </code></pre>

						</div>
					</section>

					<section id="chap4" class="three">
						<div class="container course">
							<h2> Programmation dynamique et Bellman-Ford</h2>

							<br/>

							<p>Le principe de la programmation dynamique est un principe algorithmique pour optimiser la quantité de calculs à effectuer lors de la résolution de problèmes d'optimisation.
								L'idée générale est de diviser le problème d'optimisation en une multitude de sous-problèmes plus faciles à résoudre et de stocker les résulats de ces sous-problèmes plutôt que de résoudre ces problèmes à chaque itératon.
								L'exemple le plus fréquent d'application du principe de la programmation dynamique est l'algorithme de Bellman-Ford. </p>

								<h3>Algorithme de Bellman-Ford</h3>

								<p>On se donne le graphe pondéré suivant :
									<div class="center"><img src="figures/BellmanFord.png" alt="" /></div>
									Le poids sur chaque arrête correspond au temps nécessaire pour traverser cette arrête. On se demande quel est le plus court chemin pour relier A à B. <br/>

									L'algorithme de Bellman-Ford permet de trouver efficacement un tel chemin. Il fonctionne de la manière suivante : en partant de A, on évalue le coût nécessaire pour aller à chaque voisin de A.
									Ici, pour B, on trouve 1 et pour C, 2. On réitère le processus pour les voisins de B puis les voisins de C en selectionnant la valeur de coût minimale trouvée. On continue cet algorithme jusqu'à ce qu'on couvre tout le graphe.
									 <div class="center"><img src="figures/BellmanFord.gif" alt="" style="padding-top:0.5em;"/></div>
								 </p>

								 <p>En python, on pourrait implémenter l'algorithme de Bellman-Ford ainsi:
									 <pre><code class="langage-python">
Parcourus = []
ValeurDict = {}
def evaluerCout(Graphe, pointactuel):
		Parcourus.append(pointactuel)
		valeurMinimale = float("inf")
		for voisin in Graphe.voisins(pointactuel):
				if voisin in Parcourus:
						if ValeurDict[voisin] + Graphe.poidsArrete(pointactuel, voisin) <= valeurMinimale:
								valeurMinimale = ValeurDict[voisin] + Graphe.poidsArrete(pointactuel, voisin)
		ValeurDict[pointactuel] = valeurMinimale
		for voisin in Graphe.voisins(pointactuel):
				if voisin not in Parcourus:
						evaluerCout(Graphe, voisin)

Parcourus.append(pointDepart)
ValeurDict[pointDepart] = 0
for voisin in Graphe.voisins(pointDepart):
		evaluerCout(Graphe, voisin)
									 	</code></pre>


						</div>
					</section>

					<section id="chap8" class="four">
						<div class="container course">
							<h2> Problèmes</h2>

							<h3>Problème 0: Chou, mouton et loup</h3>


							<h3>Problème 1: Le solitaire</h3>
							<br/>
							<div class="center">
							<img src="figures/solitaire.jpg" alt="Un plateau de solitaire rempli." style="max-width:80%;" />
						</div>
							<p>Le jeu du solitaire est un jeu qui, comme son nom l'indique, se joue seul. La configuration de départ est un plateau rempli de billes à l'exception du trou central (cf photo ci-dessus).
								Le but du jeu est d'arriver à la configuration finale inverse : une seule bille sur le plateau, au centre. Le seul coup légal dans ce jeu est de faire sauter une bille par dessus une autre bille. Dans ce cas, la bille qui a sauté est déplacée de deux cases. La bille qui s'est fait sauter par-dessus, elle, est retirée du plateau (voir la figure ci-dessous).
							</p>
							<div class="row justify-content-center" style="padding-left:1.5em;">
								<div class="col-6 col-sm-3">
									<div class="center"><img src="figures/CoupSolitaire1.png" alt="" style="max-width:80%; max-height: 12em;" /></div>
									<p>La bille de gauche saute par dessus la bille du centre.</p>
								</div>
								<div class="col-6 col-sm-3">
									<div class="center"><img src="figures/CoupSolitaire2.png" alt="" style="max-width:80%; max-height: 12em;" /></div>
									<p>La bille de gauche se retrouve à droite, la bille du centre est retirée du plateau.</p>
								</div>
							</div>
							<p>Ce coup ne peut être réalisé que verticalement ou horizontalement, il n'est pas possible de l'effectuer en diagonale. La case d'arrivée de la bille qui saute doit être libre pour réaliser ce coup.</p>
							<h4>Exercice : </h4>
							<div class="list-container">
								<ul>
									<li><strong>1. </strong> Formaliser ce problème comme un graphe. Gagner le jeu doit se résumer à trouver un chemin sur un graphe.</li>
									<li><strong>2. </strong> Trouver une solution au solitaire en utilisant un algorithme de parcours de graphe.</li>
									<li><strong>3. </strong> Généraliser le problème : est-il possible d'atteindre n'importe quelle situation finale ? En partant de n'importe quelle situation finale ?</li>
									<li><strong>4. </strong> Trouver une situation initiale permettant d'arriver à la configuration suivante :
										<div class="center"><img src="figures/ConfigExo2.png" alt="" style="max-width:30%;padding-top:0.5em;"/></div>
										Au maximum, combien de billes possède une telle configuration initiale ?</li>
								</ul>
							</div>

							<h3>Problème 2: Itinéraire RATP </h3>

							<br/>

							<p>On souhaite coder un outil de recherche d'itinéraire en région parisienne en utilisant exclusivement les transports en commun et la marche.
								On utilise la base de données SQL téléchargeable <a href="ressources/RATPnetwork.db">ICI </a>. La base de données est un extrait des données ouvertes et publiques trouvables sur <a href="https://www.data.gouv.fr/fr/datasets/positions-geographiques-des-stations-du-reseau-ferre-ratp-idf/">data.gouv.fr</a>.
							</p>

							<div class="center">
								<img src="figures/ReseauRATP.png" alt="" style="max-width:80%;" />
							</div>

							<h4>Exercice : </h4>
							<div class="list-container">
								<ul>
									<li><strong>1. </strong> Afficher le graphe du réseau RATP avec networkx. On utilisera sqlite3 pour récupérer les données dans la base de donnée.</li>
									<li><strong>2. </strong> Formaliser le problème sous la forme d'un graphe pondéré. Attention : on peut passer d'une station à l'autre en marchant.</li>
									<li><strong>3. </strong> En utilisant un algorithme type Bellman-Ford, trouver le chemin le plus court en transport en commun entre deux stations. On supposera que changer de ligne de transport prend 5 minutes et que, sur une même ligne, passer d'une station à l'autre prend 2 minutes.</li>
									<li><strong>4. </strong> Même question mais cette fois, on cherche le trajet le plus court entre deux points de l'espace (pas forcément des stations). On considère que la vitesse de marche est de 4km/h.</li>
									<li><strong>5. </strong> Créer une interface utilisateur pour permettre à un utilisateur ne connaissant pas python d'utiliser les fonctions précédentes.</li>
								</ul>
							</div>


						</div>
					</section>
			</div>

		<!-- Footer -->
			<div id="footer">

				<!-- Copyright -->
					<ul class="copyright">
						<li>&copy; Theo Girard. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/custom.js"></script>
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/browser.min.js"></script>
			<script src="../assets/js/breakpoints.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

      <!-- Gestion des boites de code -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
      <script>hljs.highlightAll();</script>

			<script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  			</script>

	</body>
</html>
