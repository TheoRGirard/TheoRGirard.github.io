<!DOCTYPE HTML>
<!--
	Prologue by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Theo Girard</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<link href="../assets/css/custom.css" rel="stylesheet">
		<link rel="icon" type="image/x-icon" href="../images/favMath.png">
	</head>
	<body class="is-preload">

		<!-- Header -->
			<div id="header">

				<div class="top">

					<!-- Logo -->
						<div id="logo">
							<a href="/#CoursesList" id="about-link"><span class="icon solid fa-arrow-left backButton">Retour</span></a>
						</div>

					<!-- Nav -->
						<nav id="nav">
							<ul>
								<li><a href="#chap1" id="chap1-link">Introduction</a></li>
								<li><a href="#chap2" id="chap2-link">Théorèmes</a></li>
                <li><a href="#chap3" id="chap3-link">Parcours DFS/BFS</a></li>
                <li><a href="#chap4" id="chap4-link">Programmation dynamique</a></li>
								<li><a href="#chap5" id="chap5-link">Max flow / Min cut</a></li>
								<li><a href="#chap6" id="chap6-link">Tri topologique</a></li>
								<li><a href="#chap8" id="chap8-link">Problèmes</a></li>
							</ul>
						</nav>

				</div>

				<div class="bottom">

					<!-- Social Icons -->
						<ul class="icons">
							<li><a href="https://github.com/TheoRGirard" class="icon brands fa-github"><span class="label">Github</span></a></li>
							<li><a href="/#contact" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
						</ul>

				</div>

			</div>

		<!-- Main -->
			<div id="main">

        <section id="top" class="one dark cover">
          <div class="container">

            <header>
              <h2 class="alt">Théorie des graphes</h2>
<h3>(En construction)</h3>
            </header>

            <footer>
              <a href="#chap1" class="button scrolly">Introduction</a>
              <a href="#chap2" class="button scrolly">Théorèmes</a>
              <a href="#chap3" class="button scrolly">Parcours DFS/BFS</a>
              <a href="#chap4" class="button scrolly">Programmation dynamique</a>
							<a href="#chap5" class="button scrolly">Max flow / Min cut</a>
							<a href="#chap6" class="button scrolly">Tri topologique</a>
							<a href="#chap8" class="button scrolly">Problèmes</a>
            </footer>

          </div>
        </section>

				<!-- Portfolio -->
					<section id="chap1" class="two">
						<div class="container course">
              <header>
                <h2>Introduction</h2>
              </header>

              <p>La théorie des graphes est une branche des mathématiques qui étudie les relations entre les objets (appelés sommets ou nœuds) et les connexions entre eux (appelées arêtes ou arcs). Elle est utilisée dans de nombreux domaines comme les réseaux sociaux, les systèmes de transport, les circuits électriques et l'analyse de données.</p>

              <p><strong>Pour manipuler les graphes visuellement :</strong> <a href="https://d3gt.com/index.html">https://d3gt.com/index.html</a></p>

              <h3>Définitions de base</h3>

              <div class="definition">
              <h4>Graphe</h4>
              <p>Un <strong>graphe</strong> G est un ensemble de <strong>sommets</strong> V et un ensemble d'<strong>arêtes</strong> E. Formuellement, un graphe est défini comme une paire G = (V, E), où :</p>
              <ul>
                  <li>V est un ensemble de sommets (ou nœuds),</li>
                  <li>E est un ensemble d'arêtes, chaque arête étant une paire non ordonnée de sommets dans V (pour un graphe non orienté) ou une paire ordonnée de sommets (pour un graphe orienté).</li>
              </ul>
              </div>

              <div class="center">
                  <img src="figures/basicgraph2.png" alt="Exemple de graphe" >
                  <p>V = { 1,2,3,4,5 }<br> E = {(1,2), (1,3), (2,3), (5,2), (2,4)}</p>
              </div>

              <div class="definition">
              <h4>Graphe orienté et graphe non orienté</h4>
              <ul>
                  <li><strong>Graphe orienté</strong> : Un graphe dans lequel les arêtes sont dirigées, c'est-à-dire que chaque arête est représentée par un couple ordonné de sommets (u, v), où u est le sommet de départ et v le sommet d'arrivée.</li>
                  <li><strong>Graphe non orienté</strong> : Un graphe dans lequel les arêtes ne sont pas dirigées, c'est-à-dire que chaque arête est simplement un ensemble de deux sommets {u, v}, sans ordre particulier.</li>
              </ul>
              </div>

              <div class="center">
                  <p>Exemple de graphe orienté</p>
                  <img src="figures/basicOrientedGraph.png" alt="Exemple de graphe orienté" style="width: 60%;">
                  <p>V = { 1,2,3,4,5 }<br> E = {(1,2), (1,3), (2,3), (3,2), (5,2), (2,4)}</p>
              </div>

							<div class="definition">
              <h4>Graphe pondéré</h4>
              Un graphe pondéré est un graphe (orienté ou non) auquel on ajoute une fonction \(\omega : E \longrightarrow \mathbb{R}\). On appelle \(\omega\) la fonction de poids.
              </div>
							<p>Le poids d'une arrête peut être interprêté comme le temps nécessaire pour parcourir l'arrête ou, plus généralement, comme un coût à payer pour traverser l'arrête.</p>
							<div class="center">
                  <p>Exemple de graphe pondéré non orienté</p>
                  <img src="figures/BellmanFord.png" alt="Exemple de graphe pondéré" style="width: 60%;">
                  <p>V = { A,B,C,D,E,F,G,H }<br/> E = {(A,B), (A,C), (C,E), (B,D), (D,E), (D,F), (F,H), (H,G), (E,G)}
									<br/> \( \omega((A,B)) = 1, \; \omega((B,D)) = 3, \; \omega((E,G)) = 2,\) ...
								</p>
              </div>


              <div class="definition">
              <h4>Voisins et degré d'un sommet</h4>
							<p>Soit \(A \in V\). Dans le cas d'un graphe non orienté, on définit : </p>
								<ul>
								<li>l'ensemble des voisins \(\mathcal{V}(A)\) est l'ensemble des sommets \(B \in V\) tels que \( (A,B) \in E \),</li>
              <li>le <strong>degré</strong> d'un sommet \(A\), noté \( \mathbf{deg}(A) \), est le nombre d'arêtes qui touchent \(A\). C'est à dire le cardinal de \(\mathcal{V}(A)\).</li>
						</ul>
              <p>Dans le cas d'un graphe orienté, on parle plutôt de : <p>
								<ul>
								<li>l'ensemble des <strong>prédécesseurs</strong> d'un sommet \(A\) notés \(\mathcal{P}(A)\) défini par :
								\[ \mathcal{P}(A) := \{ B \in V \textrm{ tels que } (B,A) \in E \}, \]</li>
								<li>l'ensemble des <strong>successeurs</strong> de \(A\) noté \(\mathcal{S}(A)\) défini par :
								\[ \mathcal{S}(A) := \{ B \in V \textrm{ tels que } (A,B) \in E \}. \]</li>
							</ul>
								Alors on définit le <strong>degré entrant</strong> de \(A\) noté \(d^-(A)\) par \( d^-(A) = \mathbf{Card}(\mathcal{P}(A))\).
								De même, le <strong>degré sortant</strong> de \(A\) noté \(d^+(A)\) est défini par \( d^+(A) = \mathbf{Card}(\mathcal{S}(A))\)
							</p>
              </div>

              <div class="definition">
              <h4>Chemin et cycles</h4>
              <p>Un <strong>chemin</strong> est une séquence de sommets dans laquelle chaque sommet est adjacent au suivant. Un <strong>cycle</strong> est un chemin dont le premier et le dernier sommet sont identiques.</p>
              </div>

              <h3>Dessiner un graphe en python</h3>
              <p>Dans ce cours, les graphes seront représentés avec les bibliothèques python <code>networkx</code> et <code>matplotlib</code>.</p>

              <div class="code-block">
                  <pre><code>#On importe les deux bibliothèques
import networkx as nx
import matplotlib.pyplot as plt

#On créé le graphe
G = nx.Graph() #Non-orienté
#G = nx.DiGraph() #Orienté

#On créé les noeuds
G.add_node(1)
G.add_nodes_from ([2,3,4,5])

#On ajoute les arrêtes entre les noeuds
G.add_edge(1,2)
e = (2,3)
G.add_edge(*e) # the * unpacks the tuple
G.add_edges_from([(1,2),(1,3),(2,4),(2,5)])

#On dessine le graphe
nx.draw(G, with_labels =True)

#On peut sauvegarder la figure
plt.savefig("basicgraph2.png")

#Ou juste l'afficher
plt.show()</code></pre>
              </div>

              <p>On obtient le résultat suivant :</p>

              <div class="center">
                  <img src="figures/basicgraph2.png" alt="Résultat du graphe" style="width: 60%;">
              </div>

						</div>
					</section>

          <section id="chap2" class="three">
						<div class="container">

							<header>
								<h2>Théorèmes</h2>
							</header>

							<p>Quelques théorèmes de base de la théorie des graphes.</p>

						</div>
					</section>

          <section id="chap3" class="two">
						<div class="container course">

							<header>
								<h2>Parcours de graphe DFS/BFS</h2>
							</header>

							<p>Dans de multiples problèmes nous sommes amenés à parcourir un graphe, c'est-à-dire aller de sommets en sommets en suivant les arrêtes du graphe. Par exemple, pour savoir si deux sommets sont connectés ou pour savoir si le graphe comporte un cycle.
              Pour parcourir un graphe, il existe principalement deux manières de procéder : l'exploration en profondeur DFS (Depth First Search) ou l'exploration en largeur (Breadth First Search).
              Ces deux algorithmes ont des temps de calcul très variables (et complémentaires) en fonction de la forme du graphe.</p>

              <h3> Parcours en profondeur DFS </h3>
              <br/>

              <p>Le parcours en profondeur consiste à parcourir le graphe en utilisant la stratégie suivante : si je suis à une intersection, je choisis une arrête arbitrairement; je continue ce chemin jusqu'à être coincé ou jusqu'à ce que j'aie trouvé ce que je cherche. Si je suis coincé, je reviens sur mes pas jusqu'à la dernière intersection.
                Cette stratégie correspond à la stratégie bien connue pour trouver la sortie d'un labyrinthe : toujours prendre à gauche.
                Voici deux illustrations de la stratégie DFS pour trouver un chemin du sommet A au sommet F à gauche et pour trouver un chemin du sommet A au sommet H à droite.</p>

                <div class="center">
                  En vert, le sommet actuel. En jaune, le sommet qu'on recherche. En rouge les sommets déjà parcourus.
                    <img src="figures/DFS1.gif" alt="Parcours DFS de graphe qui aboutit." style="margin-right:0.5em;max-width: 60%;"><img src="figures/DFS2.gif" alt="Parcours DFS de graphe qui n'aboutit pas." style="max-width: 60%;">
                </div>

              <p>D'un point de vue code, on utilise la plupart du temps un algorithme récursif (bien qu'un algo itératif soit envisageable).
              Voici une implémentation possible en python, en supposant l'existence d'un objet Graphe avec une méthode Voisins qui renvoie la liste des voisins d'un sommet.</p>

              <pre><code class="langage-python">
def explorer(Graphe, sommetActuel, pointArrivee, parcourus):
    parcourus.append(sommetActuel) #On garde en mémoire les sommets par lesquels on est passé.
    if(sommetActuel == pointArrivee): #Condition d'arrêt : on a trouvé le sommet qu'on recherche.
        return True
    for voisin in Graphe.Voisins(sommetActuel): #On parcourt les voisins du sommet.
        if(voisin not in parcourus): #On vérifie qu'on n est pas déjà passé par là.
            if(explorer(Graphe, voisin, pointArrivee, parcourus)): #On continue l'exploration de ce chemin tant qu on n'est pas bloqué.
                return True
    return False #Si on n a trouvé aucun voisin qui n'a jamais été parcouru, on abandonne ce chemin.
                </code></pre>

                <br/>
                <br/>


                <h3> Parcours en largeur BFS </h3>
                <br/>

                <p>Le parcours en largeur consiste à utiliser la stratégie suivante : on explore tous les voisins du point de départ, on liste tous les voisins de ces voisins qui n'ont pas encore été parcourus; on réitère le procédé sur cette nouvelle liste de voisins jusqu'à trouver ce qu'on cherche ou jusqu'à ce qu'on ne trouve plus de voisin non parcourus.
                  Cet algorithme correspond à un parcours par "génération" de voisin. En effet, si on définit la distance de voisinage entre deux sommets A et B comme le nombre d'arrêtes minimal pour passer de A à B, alors le parcours BFS va parcourir tous les sommets à distance 1 du point de départ puis tous les voisins à distance 2 et ainsi de suite.
                  Voici une illustration dans le même contexte que le parcours DFS pour comparer. </p>

                <div class="center">
                  En vert, le sommet actuel. En jaune, le sommet qu'on recherche. En rouge les sommets déjà parcourus.
                    <img src="figures/BFS2.gif" alt="Parcours BFS de graphe qui aboutit."style="max-width: 70%;">
                </div>

                <p>Le parcours BFS est généralement implémenté comme un algorithme itératif à la différence du DFS. En voici une implémentation possible en python, en supposant l'existence d'un objet Graphe avec une méthode Voisins qui renvoie la liste des voisins d'un sommet.</p>

                <pre><code class="langage-python">
def explore(Graphe, pointDepart, pointArrivee):
      parcourus = []
      nodesToexplore = [pointDepart] #La liste des noeuds à explorer qui sera tenue à jour à chaque itération.
      while(len(nodesToexplore) > 0):
          newNodes = []
          for node in nodesToexplore:
              if(node == pointArrivee): #Condition d'arrêt : si on a trouvé le point d'arrivée, on arrête.
                  return True
              parcourus.append(node)
              for P in Graphe.Voisins(node):
                  if(P not in parcourus):
                      newNodes.append(P) #On remplit la liste newNodes de tous les voisins non parcourus de la prochaine génération.
          nodesToexplore = newNodes
      return False #Si on a plus aucun noeud à explorer, c'est qu'il n'existe pas de chemin reliant le point de départ au point d'arrivée.
                  </code></pre>

						</div>
					</section>

					<section id="chap4" class="three">
						<div class="container course">
							<h2> Programmation dynamique et Bellman-Ford</h2>

							<br/>

							<p>Le principe de la programmation dynamique est un principe algorithmique pour optimiser la quantité de calculs à effectuer lors de la résolution de problèmes d'optimisation.
								L'idée générale est de diviser le problème d'optimisation en une multitude de sous-problèmes plus faciles à résoudre et de stocker les résulats de ces sous-problèmes plutôt que de résoudre ces problèmes à chaque itératon.
								L'exemple le plus fréquent d'application du principe de la programmation dynamique est l'algorithme de Bellman-Ford. </p>

								<h3>Algorithme de Bellman-Ford</h3>

								<p>On se donne le graphe pondéré suivant :
									<div class="center"><img src="figures/BellmanFord.png" alt="" style="max-width: 70%;"/></div>
									Le poids sur chaque arrête correspond au temps nécessaire pour traverser cette arrête. On se demande quel est le plus court chemin pour relier A à B. <br/>

									L'algorithme de Bellman-Ford permet de trouver efficacement un tel chemin. Il fonctionne de la manière suivante : en partant de A, on évalue le coût nécessaire pour aller à chaque voisin de A.
									Ici, pour B, on trouve 1 et pour C, 2. On réitère le processus pour les voisins de B puis les voisins de C en selectionnant la valeur de coût minimale trouvée. On continue cet algorithme jusqu'à ce qu'on couvre tout le graphe.
									 <div class="center"><img src="figures/BellmanFord.gif" alt="" style="padding-top:0.5em;max-width: 70%;"/></div>
								 </p>

								 <p>En python, on pourrait implémenter l'algorithme de Bellman-Ford ainsi:
									 <pre><code class="langage-python">
Parcourus = []
ValeurDict = {}
def evaluerCout(Graphe, pointactuel):
		Parcourus.append(pointactuel)
		valeurMinimale = float("inf")
		for voisin in Graphe.voisins(pointactuel):
				if voisin in Parcourus:
						if ValeurDict[voisin] + Graphe.poidsArrete(pointactuel, voisin) <= valeurMinimale:
								valeurMinimale = ValeurDict[voisin] + Graphe.poidsArrete(pointactuel, voisin)
		ValeurDict[pointactuel] = valeurMinimale
		for voisin in Graphe.voisins(pointactuel):
				if voisin not in Parcourus:
						evaluerCout(Graphe, voisin)

Parcourus.append(pointDepart)
ValeurDict[pointDepart] = 0
for voisin in Graphe.voisins(pointDepart):
		evaluerCout(Graphe, voisin)
									 	</code></pre>


						</div>
					</section>

					<section id="chap5" class="two">
						<div class="container course">
							<h2> Flot maximal et coupe minimale</h2>

							<br/>
							<h3>Problème de flot maximal</h3>
							Avant d'énoncer le problème du flot maximal, on introduit deux définition supplémentaires.
							<div class="definition">
              <h4>Réseau de flot</h4>
              <p>Un réseau de flot est un graphe pondéré orienté \( G = (V,E,c) \) qui vérifie :</p>
								<ul>
	                  <li>les poids des arrêtes sont strictement positifs (i.e. \( c > 0 \) ),</li>
										<li>si \((A,B) \in E \) alors \((B,A) \notin E \).</li>
								</ul>
									 La fonction poids \(\omega\) est appelée "capacité".
              </div>

							<div class="definition">
              <h4>Flot associé à un graphe \(G\)</h4>
              <p>Soit \( G = (V,E,c) \) un réseau de flot. Soient \( s, t \in V \) deux sommets particuliers que l'on nomme respectivement la source et le puits. On suppose que \(s\) n'a pas de prédécesseur et que \(t\) n'a pas de successeur dans \(G\).
								On dit que la fonction \( f : E \longrightarrow \mathbb{R} \) est un <strong>flot de \(s\) à \(t\)</strong> si :
							</p>
							<ul>
                  <li>pour toute arrête \((A,B) \in E,\; 0 \leq f((A,B)) \leq c((A,B))\),</li>
                  <li>pour tout sommet \(A \in V,\) si \(A \neq s \) et si \(A \neq t\), alors \[ \sum\limits_{B \in \mathcal{P}(A)} f((B,A)) = \sum\limits_{B \in \mathcal{S}(A)} f((A,B))\] où \( \mathcal{P}(A), \mathcal{S}(A) \) sont respectivement l'ensemble des prédécesseurs de \(A\) et l'ensemble des successeurs de \(A\).</li>
              </ul>
							<p>
							La valeur \(|f|\) d'un flot \(f\) est définie par :
							\[|f| = \sum\limits_{B \in \mathcal{V}(s)} f((s,B)) = \sum\limits_{A \in \mathcal{V}(t)} f((A,t)).\]
						</p>
              </div>

							<p>Si on se donne un réseau de flot \(V,E,\omega\), un sommet source \(s\) et un sommet puits \(t\),
								le problème du flot maximal est donc de trouver un flot \(f\) de \(s\) à \(t\) de valeur \(|f|\) maximale.
							</p>

							<h3>Algorithme de Ford-Fulkerson</h3>
							<p>
							L'algorithme de Ford-Fulkerson permet de trouver un flot maximal lorsque l'algorithme termine (attention il existe des cas où l'algorithme ne termine jamais).
							Le principe de l'algorithme repose sur l'utilisation d'un graphe résiduel d'un flot \(G_f \). Si on cherche le flot maximal sur \(G = (V,E,c)\),
							le graphe résiduel \(G_f\) d'un flot \(f\) est un graphe pondéré orienté \(G_f = (V, E_{r_f}, r_f )\) (\(G_f\) a donc les mêmes sommets que \(G\)) où \(r_f\) est défini par :
							\[ \forall (A,B) \in V^2, \;\; r_f((A,B)) := \left\{ \begin{matrix} c((A,B)) - f((A,B)) & \textrm{ si } (A,B) \in E \\
							f((B,A)) & \textrm{ si } (B,A) \in E\\
							0 & \textrm{sinon} \end{matrix} \right. \]
							et \(E_{r_f} = \{ (A,B) \in V^2, \textrm{ tels que } r_f(A,B) > 0 \} \).</p>
							<p>On utilise alors l'algorithme suivant :</p>
							<div class="row" style="justify-content:center;"><div style="width:auto;text-align: left;"><ul>
								<li>on initialise le flot \(f\) comme nul;</li>
								<li>tant qu'il existe un chemin \(\gamma\) de \(s\) à \(t\) dans \(G_f\) :
									<ul>
										<li>on sélectionne \(m\) le min de \(r_f((A,B))\) pour \((A,B) \in \gamma\);</li>
										<li>pour toute arrête \( (A,B) \in \gamma,\) :
											<ul>
												<li>si \((A,B) \in E,\;\; f((A,B)) += m \);</li>
												<li>si \((A,B) \notin E,\;\; f((A,B)) -= m \);</li>
											</ul>
										</li>
									</ul>
							</ul></div>
						</div>
						<br/>
							<p>Lorsque l'algorithme se termine, le flot \( f \) est alors le flot maximal.


							<h3>Problème de la coupe minimale</h3>
							<p>Encore une fois, avant de pouvoir présenter le problème, il faut introduire de nouvelles définitions.</p>
							<div class="definition">
              <h4>Coupe d'un graphe</h4>
              <p>Une <strong>coupe</strong> coupe \(C = (S,T) \) d'un graphe \(G = (V,E) \) est la donnée de deux sous-ensemble de sommets \(S\) et \(T\) tels que : </p>
								<ul>
	                  <li>les ensembles \(S\) et \(T\) couvrent \(V\) i.e. \(V = S \cup T \),</li>
										<li>les ensembles \(S\) et \(T\) soient disjoints i.e. \(S \cap T = \emptyset\).</li>
								</ul>
								<p>Le <strong>cut-set</strong> \(Z_C\) d'une coupe \(C = (S,T) \) est l'ensemble des arrêtes coupées par la coupe i.e.
								\[Z_C := \{ (A,B) \in E, \textrm{ t. q. } A \in S \textrm{ et } B \in T \}. \]</p>
								<p>Si \(G = (V,E,\omega) \) est un graphe pondéré, le <strong>poids</strong> \(\omega_C\) d'une coupe \(C\) est la somme des poids des arrêtes de \(Z_C\) i.e.
								\[\omega_C := \sum\limits_{(A,B) \in Z_C} \omega((A,B)). \]</p>
              </div>

							<p>Le problème de la coupe minimale consiste donc à trouver la (ou une des) coupe(s) de poids minimale(s) pour un graphe pondéré donné.
							Lorsque le graphe est un réseau de flot et qu'on impose les conditions \(s \in S\) et \(t \in T\), le théorème du max flow/min cut montre que
							le problème de flot maximal et le problème de coupe minimale sont directement reliés.</p>
							<div class="theoreme">
              <h4>Max flow/min cut</h4>
              <p>Soit \( G = (V,E,c) \) un réseau de flot avec \(s,t \in V\).
								La valeur \(|f|\) du flot maximal de \(s\) à \(t\) est égal au poids \(\omega_C\) de la coupe minimal \(C = (S,T) \) telle que \(s \in S\) et \(t \in T \).</li>
							</p>
              </div>
							En sélectionnant dans le flot maximal un ensemble d'arrête dont le flot est égal à la capacité de l'arrête, on peut construire une coupe minimale.

						</div>
					</section>

					<section id="chap6" class="three">
						<div class="container course">
							<h2> Tri topologique</h2>

							<br/>

						</div>
					</section>

					<section id="chap8" class="four">
						<div class="container course">
							<h2> Problèmes</h2>

							<h3>Problème 0: Chou, mouton et loup</h3>


							<h3>Problème 1: Le solitaire</h3>
							<br/>
							<div class="center">
							<img src="figures/solitaire.jpg" alt="Un plateau de solitaire rempli." style="max-width:80%;" />
						</div>
							<p>Le jeu du solitaire est un jeu qui, comme son nom l'indique, se joue seul. La configuration de départ est un plateau rempli de billes à l'exception du trou central (cf photo ci-dessus).
								Le but du jeu est d'arriver à la configuration finale inverse : une seule bille sur le plateau, au centre. Le seul coup légal dans ce jeu est de faire sauter une bille par dessus une autre bille. Dans ce cas, la bille qui a sauté est déplacée de deux cases. La bille qui s'est fait sauter par-dessus, elle, est retirée du plateau (voir la figure ci-dessous).
							</p>
							<div class="row justify-content-center" style="padding-left:1.5em;">
								<div class="col-6 col-sm-3">
									<div class="center"><img src="figures/CoupSolitaire1.png" alt="" style="max-width:80%; max-height: 12em;" /></div>
									<p>La bille de gauche saute par dessus la bille du centre.</p>
								</div>
								<div class="col-6 col-sm-3">
									<div class="center"><img src="figures/CoupSolitaire2.png" alt="" style="max-width:80%; max-height: 12em;" /></div>
									<p>La bille de gauche se retrouve à droite, la bille du centre est retirée du plateau.</p>
								</div>
							</div>
							<p>Ce coup ne peut être réalisé que verticalement ou horizontalement, il n'est pas possible de l'effectuer en diagonale. La case d'arrivée de la bille qui saute doit être libre pour réaliser ce coup.</p>
							<h4>Exercice : </h4>
							<div class="list-container">
								<ul>
									<li><strong>1. </strong> Formaliser ce problème comme un graphe. Gagner le jeu doit se résumer à trouver un chemin sur un graphe.</li>
									<li><strong>2. </strong> Trouver une solution au solitaire en utilisant un algorithme de parcours de graphe.</li>
									<li><strong>3. </strong> Généraliser le problème : est-il possible d'atteindre n'importe quelle situation finale ? En partant de n'importe quelle situation finale ?</li>
									<li><strong>4. </strong> Trouver une situation initiale permettant d'arriver à la configuration suivante :
										<div class="center"><img src="figures/ConfigExo2.png" alt="" style="max-width:30%;padding-top:0.5em;"/></div>
										Au maximum, combien de billes possède une telle configuration initiale ?</li>
								</ul>
							</div>

							<h3>Problème 2: Itinéraire RATP </h3>

							<br/>

							<p>On souhaite coder un outil de recherche d'itinéraire en région parisienne en utilisant exclusivement les transports en commun et la marche.
								On utilise la base de données SQL téléchargeable <a href="ressources/RATPnetwork.db">ICI </a>. La base de données est un extrait des données ouvertes et publiques trouvables sur <a href="https://www.data.gouv.fr/fr/datasets/positions-geographiques-des-stations-du-reseau-ferre-ratp-idf/">data.gouv.fr</a>.
							</p>

							<div class="center">
								<img src="figures/ReseauRATP.png" alt="" style="max-width:80%;" />
							</div>

							<h4>Exercice : </h4>
							<div class="list-container">
								<ul>
									<li><strong>1. </strong> Afficher le graphe du réseau RATP avec networkx. On utilisera sqlite3 pour récupérer les données dans la base de donnée.</li>
									<li><strong>2. </strong> Formaliser le problème sous la forme d'un graphe pondéré. Attention : on peut passer d'une station à l'autre en marchant.</li>
									<li><strong>3. </strong> En utilisant un algorithme type Bellman-Ford, trouver le chemin le plus court en transport en commun entre deux stations. On supposera que changer de ligne de transport prend 5 minutes et que, sur une même ligne, passer d'une station à l'autre prend 2 minutes.</li>
									<li><strong>4. </strong> Même question mais cette fois, on cherche le trajet le plus court entre deux points de l'espace (pas forcément des stations). On considère que la vitesse de marche est de 4km/h.</li>
									<li><strong>5. </strong> Créer une interface utilisateur pour permettre à un utilisateur ne connaissant pas python d'utiliser les fonctions précédentes.</li>
								</ul>
							</div>

							<h3>Problème 3 : répartition minière</h3>

							<br/>
							<div class="center">
							<img src="figures/minerai-de-fer.jpg" alt="Un plateau de solitaire rempli." style="max-width:80%;" />
						</div>
							<p>Une entreprise veut exploiter une carrière de fer.
								L'entreprise souhaite savoir combien de minerai de fer elle peut extraire en fonction de ce que les entreprises locales sont prêtes à lui acheter.
								En faisant un sondage, on obtient les informations suivantes (exprimées en tonnes par mois notés \(t/m\) ) :</p>
								<ul>
									<li>L'entreprise \(A\) peut transformer \(300 t/m\) de minerai de fer en acier brut.</li>
									<li>L'entreprise \(B\) peut transformer \(120 t/m\) de minerai de fer en acier raffiné.</li>
									<li>L'entreprise \(C\) peut transformer \(230 t/m\) de minerai de fer en acier brut.</li>
									<li>L'entreprise \(D\) peut transformer \(80t/m\) d'acier raffiné en pièces automobiles.</li>
									<li>L'entreprise \(E\) peut transformer \(260 t/m\) d'acier brut en quincaillerie.</li>
									<li>L'entreprise \(G\) peut transformer \(300 t/m\) de quincaillerie en pièces automobiles.</li>
									<li>L'entreprise \(H\) peut transformer \(170 t/m\) d'acier raffiné en quincaillerie.</li>
									<li>L'entreprise \(I\) peut transformer \(110 t/m\) d'acier raffiné et \(130t/m \) d'acier brut en plaques d'acier.</li>
									<li>L'entreprise \(J\) peut transformer \(260 t/m\) de plaques d'acier en pièces automobiles.</li>
									<li>L'entreprise \(K\) peut transformer \(180 t/m\) d'acier brut en acier raffiné.</li>
									<li>L'entreprise \(L\) rachète toute pièce automobile de la région, elle a le monopole complet.</li>
								</ul>
								<p>L'entreprise souhaiterait savoir combien de tonnes de minerai de fer elle pourrait espérer vendre par mois étant donné l'écosystème régional.</p>

								<h4>Exercice : </h4>
								<div class="list-container">
									<ul>
										<li><strong>1. </strong> Reformuler le problème comme un problème de flot maximal (Attention : il faut bien choisir ce que sont les sommets du graphe).</li>
										<li><strong>2. </strong> À l'aide d'un algorithme de Ford-Fulkerson (ou d'un autre algorithme de max flow externe comme scipy), répondre à la question de l'entreprise.</li>
										<li><strong>3. </strong> Si l'entreprise \(I\) ferme quel serait l'impact sur la demande de minerai ? Même question pour l'entreprise \(H\).</li>
										<li><strong>4. </strong> Trouver une coupe minimale du graphe obtenu. Que représente les deux sous-ensembles de sommets obtenus ?</li>
									</ul>
								</div>


						</div>
					</section>
			</div>

		<!-- Footer -->
			<div id="footer">

				<!-- Copyright -->
					<ul class="copyright">
						<li>&copy; Theo Girard. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/custom.js"></script>
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/browser.min.js"></script>
			<script src="../assets/js/breakpoints.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

      <!-- Gestion des boites de code -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
      <script>hljs.highlightAll();</script>

			<script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  			</script>

	</body>
</html>
