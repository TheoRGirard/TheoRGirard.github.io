<!DOCTYPE HTML>
<!--
	Prologue by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Theo Girard</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<link href="../assets/css/custom.css" rel="stylesheet">
		<link rel="icon" type="image/x-icon" href="../images/favMath.png">
	</head>
	<body class="is-preload">

		<!-- Header -->
			<div id="header">

				<div class="top">

					<!-- Logo -->
						<div id="logo">
							<a href="/" id="about-link"><span class="icon solid fa-arrow-left backButton">Retour</span></a>
						</div>

					<!-- Nav -->
						<nav id="nav">
							<ul>
								<li><a href="#chap1" id="chap1-link">Introduction</a></li>
								<li><a href="#chap2" id="chap2-link">Théorèmes</a></li>
                <li><a href="#chap3" id="chap3-link">Parcours DFS/BFS</a></li>
                <li><a href="#chap4" id="chap4-link">Programmation dynamique et Bellman-Ford</a></li>
							</ul>
						</nav>

				</div>

				<div class="bottom">

					<!-- Social Icons -->
						<ul class="icons">
							<li><a href="https://github.com/TheoRGirard" class="icon brands fa-github"><span class="label">Github</span></a></li>
							<li><a href="/#contact" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
						</ul>

				</div>

			</div>

		<!-- Main -->
			<div id="main">

        <section id="top" class="one dark cover">
          <div class="container">

            <header>
              <h2 class="alt">Théorie des graphes</h2>

            </header>

            <footer>
              <a href="#chap1" class="button scrolly">Introduction</a>
              <a href="#chap2" class="button scrolly">Théorèmes</a>
              <a href="#chap3" class="button scrolly">Parcours DFS/BFS</a>
              <a href="#chap4" class="button scrolly">Programmation dynamique et Bellman-Ford</a>
            </footer>

          </div>
        </section>

				<!-- Portfolio -->
					<section id="chap1" class="two">
						<div class="container course">
              <header>
                <h2>Introduction</h2>
              </header>

              <p>La théorie des graphes est une branche des mathématiques qui étudie les relations entre les objets (appelés sommets ou nœuds) et les connexions entre eux (appelées arêtes ou arcs). Elle est utilisée dans de nombreux domaines comme les réseaux sociaux, les systèmes de transport, les circuits électriques et l'analyse de données.</p>

              <p><strong>Pour manipuler les graphes visuellement :</strong> <a href="https://d3gt.com/index.html">https://d3gt.com/index.html</a></p>

              <h3>Définitions de base</h3>

              <div class="definition">
              <h4>Graphe</h4>
              <p>Un <strong>graphe</strong> G est un ensemble de <strong>sommets</strong> V et un ensemble d'<strong>arêtes</strong> E. Formuellement, un graphe est défini comme une paire G = (V, E), où :</p>
              <ul>
                  <li>V est un ensemble de sommets (ou nœuds),</li>
                  <li>E est un ensemble d'arêtes, chaque arête étant une paire non ordonnée de sommets dans V (pour un graphe non orienté) ou une paire ordonnée de sommets (pour un graphe orienté).</li>
              </ul>
              </div>

              <div class="center">
                  <img src="figures/basicgraph2.png" alt="Exemple de graphe" >
                  <p>V = { 1,2,3,4,5 }<br> E = {(1,2), (1,3), (2,3), (5,2), (2,4)}</p>
              </div>

              <div class="definition">
              <h4>Graphe Orienté et Graphe Non Orienté</h4>
              <ul>
                  <li><strong>Graphe orienté</strong> : Un graphe dans lequel les arêtes sont dirigées, c'est-à-dire que chaque arête est représentée par un couple ordonné de sommets (u, v), où u est le sommet de départ et v le sommet d'arrivée.</li>
                  <li><strong>Graphe non orienté</strong> : Un graphe dans lequel les arêtes ne sont pas dirigées, c'est-à-dire que chaque arête est simplement un ensemble de deux sommets {u, v}, sans ordre particulier.</li>
              </ul>
              </div>

              <div class="center">
                  <p>Exemple de graphe orienté</p>
                  <img src="figures/basicOrientedGraph.png" alt="Exemple de graphe orienté" style="width: 40%;">
                  <p>V = { 1,2,3,4,5 }<br> E = {(1,2), (1,3), (2,3), (3,2), (5,2), (2,4)}</p>
              </div>

              <div class="definition">
              <h4>Degré d'un Sommet</h4>
              <p>Le <strong>degré</strong> d'un sommet v, noté deg(v), est le nombre d'arêtes qui touchent v.</p>
              <p>Dans un graphe orienté, on distingue le <strong>degré entrant</strong> et le <strong>degré sortant</strong>.</p>
              </div>

              <div class="definition">
              <h4>Chemin et Cycle</h4>
              <p>Un <strong>chemin</strong> est une séquence de sommets dans laquelle chaque sommet est adjacent au suivant. Un <strong>cycle</strong> est un chemin dont le premier et le dernier sommet sont identiques.</p>
              </div>

              <h3>Dessiner un graphe en python</h3>
              <p>Dans ce cours, les graphes seront représentés avec les bibliothèques python <code>networkx</code> et <code>matplotlib</code>.</p>

              <div class="code-block">
                  <pre><code>#On importe les deux bibliothèques
import networkx as nx
import matplotlib.pyplot as plt

#On créé le graphe
G = nx.Graph() #Non-orienté
#G = nx.DiGraph() #Orienté

#On créé les noeuds
G.add_node(1)
G.add_nodes_from ([2,3,4,5])

#On ajoute les arrêtes entre les noeuds
G.add_edge(1,2)
e = (2,3)
G.add_edge(*e) # the * unpacks the tuple
G.add_edges_from([(1,2),(1,3),(2,4),(2,5)])

#On dessine le graphe
nx.draw(G, with_labels =True)

#On peut sauvegarder la figure
plt.savefig("basicgraph2.png")

#Ou juste l'afficher
plt.show()</code></pre>
              </div>

              <p>On obtient le résultat suivant :</p>

              <div class="center">
                  <img src="figures/basicgraph2.png" alt="Résultat du graphe" style="width: 40%;">
              </div>

						</div>
					</section>

          <section id="chap2" class="three">
						<div class="container">

							<header>
								<h2>Théorèmes</h2>
							</header>

							<p>Quelques théorèmes de base de la théorie des graphes.</p>

						</div>
					</section>

          <section id="chap3" class="two">
						<div class="container course">

							<header>
								<h2>Parcours de graphe DFS/BFS</h2>
							</header>

							<p>Dans de multiples problèmes nous sommes amenés à parcourir un graphe, c'est-à-dire aller de sommets en sommets en suivant les arrêtes du graphe. Par exemple, pour savoir si deux sommets sont connectés ou pour savoir si le graphe comporte un cycle.
              Pour parcourir un graphe, il existe principalement deux manières de procéder : l'exploration en profondeur DFS (Depth First Search) ou l'exploration en largeur (Breadth First Search).
              Ces deux algorithmes ont des temps de calcul très variables (et complémentaires) en fonction de la forme du graphe.</p>

              <h3> Parcours en profondeur DFS </h3>
              <br/>

              <p>Le parcours en profondeur consiste à parcourir le graphe en utilisant la stratégie suivante : si je suis à une intersection, je choisis une arrête arbitrairement; je continue ce chemin jusqu'à être coincé ou jusqu'à ce que j'aie trouvé ce que je cherche. Si je suis coincé, je reviens sur mes pas jusqu'à la dernière intersection.
                Cette stratégie correspond à la stratégie bien connue pour trouver la sortie d'un labyrinthe : toujours prendre à gauche.
                Voici deux illustrations de la stratégie DFS pour trouver un chemin du sommet A au sommet F à gauche et pour trouver un chemin du sommet A au sommet H à droite.</p>

                <div class="center">
                  En vert, le sommet actuel. En jaune, le sommet qu'on recherche. En rouge les sommets déjà parcourus.
                    <img src="figures/DFS1.gif" alt="Parcours DFS de graphe qui aboutit." style="margin-right:0.5em;"><img src="figures/DFS2.gif" alt="Parcours DFS de graphe qui n'aboutit pas.">
                </div>

              <p>D'un point de vue code, on utilise la plupart du temps un algorithme récursif (bien qu'un algo itératif soit envisageable).
              Voici une implémentation possible en python, en supposant l'existence d'un objet Graphe avec une méthode Voisins qui renvoie la liste des voisins d'un sommet.</p>

              <pre><code class="langage-python">
def explorer(Graphe, sommetActuel, pointArrivee, parcourus):
    parcourus.append(sommetActuel) #On garde en mémoire les sommets par lesquels on est passé.
    if(sommetActuel == pointArrivee): #Condition d'arrêt : on a trouvé le sommet qu'on recherche.
        return True
    for voisin in Graphe.Voisins(sommetActuel): #On parcourt les voisins du sommet.
        if(voisin not in parcourus): #On vérifie qu'on n est pas déjà passé par là.
            if(explorer(Graphe, voisin, pointArrivee, parcourus)): #On continue l'exploration de ce chemin tant qu on n'est pas bloqué.
                return True
    return False #Si on n a trouvé aucun voisin qui n'a jamais été parcouru, on abandonne ce chemin.
                </code></pre>

                <br/>
                <br/>


                <h3> Parcours en largeur BFS </h3>
                <br/>

                <p>Le parcours en largeur consiste à utiliser la stratégie suivante : on explore tous les voisins du point de départ, on liste tous les voisins de ces voisins qui n'ont pas encore été parcourus; on réitère le procédé sur cette nouvelle liste de voisins jusqu'à trouver ce qu'on cherche ou jusqu'à ce qu'on ne trouve plus de voisin non parcourus.
                  Cet algorithme correspond à un parcours par "génération" de voisin. En effet, si on définit la distance de voisinage entre deux sommets A et B comme le nombre d'arrêtes minimal pour passer de A à B, alors le parcours BFS va parcourir tous les sommets à distance 1 du point de départ puis tous les voisins à distance 2 et ainsi de suite.
                  Voici une illustration dans le même contexte que le parcours DFS pour comparer. </p>

                <div class="center">
                  En vert, le sommet actuel. En jaune, le sommet qu'on recherche. En rouge les sommets déjà parcourus.
                    <img src="figures/BFS2.gif" alt="Parcours BFS de graphe qui aboutit.">
                </div>

                <p>Le parcours BFS est généralement implémenté comme un algorithme itératif à la différence du DFS. En voici une implémentation possible en python, en supposant l'existence d'un objet Graphe avec une méthode Voisins qui renvoie la liste des voisins d'un sommet.</p>

                <pre><code class="langage-python">
def explore(Graphe, pointDepart, pointArrivee):
      parcourus = []
      nodesToexplore = [pointDepart] #La liste des noeuds à explorer qui sera tenue à jour à chaque itération.
      while(len(nodesToexplore) > 0):
          newNodes = []
          for node in nodesToexplore:
              if(node == pointArrivee): #Condition d'arrêt : si on a trouvé le point d'arrivée, on arrête.
                  return True
              parcourus.append(node)
              for P in Graphe.Voisins(node):
                  if(P not in parcourus):
                      newNodes.append(P) #On remplit la liste newNodes de tous les voisins non parcourus de la prochaine génération.
          nodesToexplore = newNodes
      return False #Si on a plus aucun noeud à explorer, c'est qu'il n'existe pas de chemin reliant le point de départ au point d'arrivée.
                  </code></pre>

						</div>
					</section>


			</div>

		<!-- Footer -->
			<div id="footer">

				<!-- Copyright -->
					<ul class="copyright">
						<li>&copy; Theo Girard. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/custom.js"></script>
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/browser.min.js"></script>
			<script src="../assets/js/breakpoints.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

      <!-- Gestion des boites de code -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
      <script>hljs.highlightAll();</script>

			<script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  			</script>

	</body>
</html>
